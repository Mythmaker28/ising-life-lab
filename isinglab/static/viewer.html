<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ising-Life-Lab CA Viewer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        h1 { color: #4a9eff; margin-bottom: 10px; }
        .container { max-width: 1400px; margin: 0 auto; }
        .controls { background: #2a2a2a; padding: 20px; border-radius: 8px; margin-bottom: 20px; }
        .control-group { margin: 15px 0; }
        label { display: inline-block; width: 150px; font-weight: bold; color: #8ab4f8; }
        input, select, button { padding: 8px; margin: 5px; border-radius: 4px; border: 1px solid #444; background: #333; color: #fff; }
        button { background: #4a9eff; color: white; cursor: pointer; font-weight: bold; border: none; }
        button:hover { background: #3a8eef; }
        button:disabled { background: #555; cursor: not-allowed; }
        #canvas { border: 2px solid #4a9eff; background: #000; image-rendering: pixelated; display: block; margin: 20px auto; }
        .stats { background: #2a2a2a; padding: 15px; border-radius: 8px; margin-top: 20px; display: flex; gap: 30px; }
        .stat-item { flex: 1; }
        .stat-label { font-size: 12px; color: #888; }
        .stat-value { font-size: 24px; font-weight: bold; color: #4a9eff; }
        .error { color: #ff4444; background: #442222; padding: 10px; border-radius: 4px; margin: 10px 0; }
        .info { color: #88ff88; background: #224422; padding: 10px; border-radius: 4px; margin: 10px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üß¨ Ising-Life-Lab CA Viewer</h1>
        <p style="color: #888;">Visualisation temps r√©el des automates cellulaires</p>
        
        <div class="controls">
            <div class="control-group">
                <label>R√®gle (notation):</label>
                <input type="text" id="ruleInput" placeholder="B3/S23" value="B3/S23" style="width: 200px;">
                ou
                <select id="hofSelect">
                    <option value="">-- Charger HoF --</option>
                </select>
                <select id="memorySelect">
                    <option value="">-- Charger Memory --</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Taille grille:</label>
                <select id="gridSize">
                    <option value="16">16x16</option>
                    <option value="32" selected>32x32</option>
                    <option value="64">64x64</option>
                    <option value="128">128x128</option>
                </select>
                
                <label style="margin-left: 30px;">Densit√© init:</label>
                <input type="number" id="density" min="0" max="1" step="0.1" value="0.3" style="width: 80px;">
                
                <label style="margin-left: 30px;">Bruit init:</label>
                <input type="number" id="noise" min="0" max="0.5" step="0.05" value="0.0" style="width: 80px;">
            </div>
            
            <div class="control-group">
                <button id="startBtn" onclick="start()">‚ñ∂ Start</button>
                <button id="pauseBtn" onclick="pause()" disabled>‚è∏ Pause</button>
                <button id="stepBtn" onclick="step()">‚è≠ Step</button>
                <button id="resetBtn" onclick="reset()">üîÑ Reset</button>
                <button onclick="applyRule()">Appliquer R√®gle</button>
            </div>
        </div>
        
        <canvas id="canvas" width="512" height="512"></canvas>
        
        <div class="stats">
            <div class="stat-item">
                <div class="stat-label">Steps</div>
                <div class="stat-value" id="stepCount">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Densit√©</div>
                <div class="stat-value" id="densityVal">0.00</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">FPS</div>
                <div class="stat-value" id="fpsVal">0</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">R√®gle Active</div>
                <div class="stat-value" id="activeRule" style="font-size: 18px;">-</div>
            </div>
        </div>
        
        <div id="messageArea"></div>
    </div>
    
    <script>
        let grid, born, survive, gridSize, canvas, ctx;
        let running = false, stepCount = 0, lastTime = 0, fps = 0;
        let animationId = null;
        
        // Init
        window.onload = () => {
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            loadHoF();
            loadMemory();
            applyRule();
        };
        
        // Load HoF
        async function loadHoF() {
            try {
                const res = await fetch('/api/hof');
                const data = await res.json();
                const select = document.getElementById('hofSelect');
                data.rules.forEach(r => {
                    const opt = document.createElement('option');
                    opt.value = r.notation;
                    opt.textContent = `${r.notation} (${r.tier || 'unknown'})`;
                    select.appendChild(opt);
                });
            } catch (e) {
                console.error('Error loading HoF:', e);
            }
        }
        
        // Load Memory
        async function loadMemory() {
            try {
                const res = await fetch('/api/memory');
                const data = await res.json();
                const select = document.getElementById('memorySelect');
                data.rules.slice(0, 20).forEach(r => {
                    const opt = document.createElement('option');
                    opt.value = r.notation;
                    const comp = r.scores?.composite || 0;
                    opt.textContent = `${r.notation} (${comp.toFixed(3)})`;
                    select.appendChild(opt);
                });
            } catch (e) {
                console.error('Error loading memory:', e);
            }
        }
        
        // Charger r√®gle depuis select
        document.getElementById('hofSelect').onchange = (e) => {
            if (e.target.value) {
                document.getElementById('ruleInput').value = e.target.value;
                document.getElementById('memorySelect').value = '';
            }
        };
        
        document.getElementById('memorySelect').onchange = (e) => {
            if (e.target.value) {
                document.getElementById('ruleInput').value = e.target.value;
                document.getElementById('hofSelect').value = '';
            }
        };
        
        // Parse notation
        function parseRule(notation) {
            const parts = notation.split('/');
            if (parts.length !== 2) return null;
            
            const bornStr = parts[0].replace('B', '');
            const surviveStr = parts[1].replace('S', '');
            
            const born = bornStr.split('').filter(c => !isNaN(c)).map(Number);
            const survive = surviveStr.split('').filter(c => !isNaN(c)).map(Number);
            
            return { born, survive };
        }
        
        // Appliquer r√®gle
        function applyRule() {
            const notation = document.getElementById('ruleInput').value.trim();
            const parsed = parseRule(notation);
            
            if (!parsed) {
                showMessage('Notation invalide. Format: B3/S23', 'error');
                return;
            }
            
            born = new Set(parsed.born);
            survive = new Set(parsed.survive);
            gridSize = parseInt(document.getElementById('gridSize').value);
            
            document.getElementById('activeRule').textContent = notation;
            showMessage(`R√®gle charg√©e: ${notation}`, 'info');
            
            reset();
        }
        
        // Init grille
        function reset() {
            pause();
            stepCount = 0;
            gridSize = parseInt(document.getElementById('gridSize').value);
            grid = new Array(gridSize).fill(0).map(() => new Array(gridSize).fill(0));
            
            // Init al√©atoire avec densit√©
            const density = parseFloat(document.getElementById('density').value);
            const noise = parseFloat(document.getElementById('noise').value);
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    grid[i][j] = Math.random() < density ? 1 : 0;
                }
            }
            
            // Ajouter bruit
            if (noise > 0) {
                const nFlips = Math.floor(gridSize * gridSize * noise);
                for (let n = 0; n < nFlips; n++) {
                    const i = Math.floor(Math.random() * gridSize);
                    const j = Math.floor(Math.random() * gridSize);
                    grid[i][j] = 1 - grid[i][j];
                }
            }
            
            draw();
            updateStats();
        }
        
        // Evolution CA
        function evolve() {
            const newGrid = grid.map(row => [...row]);
            
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    let neighbors = 0;
                    
                    for (let di = -1; di <= 1; di++) {
                        for (let dj = -1; dj <= 1; dj++) {
                            if (di === 0 && dj === 0) continue;
                            const ni = (i + di + gridSize) % gridSize;
                            const nj = (j + dj + gridSize) % gridSize;
                            neighbors += grid[ni][nj];
                        }
                    }
                    
                    if (grid[i][j] === 1) {
                        newGrid[i][j] = survive.has(neighbors) ? 1 : 0;
                    } else {
                        newGrid[i][j] = born.has(neighbors) ? 1 : 0;
                    }
                }
            }
            
            grid = newGrid;
            stepCount++;
        }
        
        // Affichage
        function draw() {
            const cellSize = Math.floor(512 / gridSize);
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#4a9eff';
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    if (grid[i][j] === 1) {
                        ctx.fillRect(j * cellSize, i * cellSize, cellSize - 1, cellSize - 1);
                    }
                }
            }
        }
        
        // Stats
        function updateStats() {
            document.getElementById('stepCount').textContent = stepCount;
            
            let alive = 0;
            for (let i = 0; i < gridSize; i++) {
                for (let j = 0; j < gridSize; j++) {
                    alive += grid[i][j];
                }
            }
            const density = alive / (gridSize * gridSize);
            document.getElementById('densityVal').textContent = density.toFixed(3);
        }
        
        // Contr√¥les
        function start() {
            if (running) return;
            running = true;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            lastTime = Date.now();
            animate();
        }
        
        function pause() {
            running = false;
            document.getElementById('startBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
        }
        
        function step() {
            pause();
            evolve();
            draw();
            updateStats();
        }
        
        function animate() {
            if (!running) return;
            
            evolve();
            draw();
            updateStats();
            
            // FPS
            const now = Date.now();
            fps = Math.round(1000 / (now - lastTime));
            document.getElementById('fpsVal').textContent = fps;
            lastTime = now;
            
            animationId = requestAnimationFrame(animate);
        }
        
        // Messages
        function showMessage(msg, type) {
            const area = document.getElementById('messageArea');
            const div = document.createElement('div');
            div.className = type;
            div.textContent = msg;
            area.innerHTML = '';
            area.appendChild(div);
            setTimeout(() => div.remove(), 5000);
        }
    </script>
</head>
<body>
</body>
</html>

